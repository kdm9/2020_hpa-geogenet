---
title: Construct on Hpa
date: 2021-01-02
author: Kevin Murray
---

Have now separated out the conStruct notebook.

```{r setup, include=F, cache=F}
if (!require("tidyverse"))         { install.packages("tidyverse")                      ; require("tidyverse")          }
if (!require("foreach"))           { install.packages("foreach")                        ; require("foreach")            }
if (!require("doParallel"))        { install.packages("doParallel")                     ; require("doParallel")         }
if (!require("parallel"))          { install.packages("parallel")                       ; require("parallel")           }
if (!require("ggplot2"))           { install.packages("ggplot2")                        ; require("ggplot2")            }
if (!require("ggrepel"))           { install.packages("ggrepel")                        ; require("ggrepel")            }
if (!require("ggmap"))             { install.packages("ggmap")                          ; require("ggmap")              }
if (!require("scatterpie"))        { install.packages("scatterpie")                     ; require("scatterpie")         }
if (!require("RColorBrewer"))      { install.packages("RColorBrewer")                   ; require("RColorBrewer")       }
if (!require("fossil"))            { install.packages("fossil")                         ; require("fossil")             }
if (!require("vegan"))             { install.packages("vegan")                          ; require("vegan")              }
if (!require("SNPRelate"))         { BiocManager::install("SNPRelate")                  ; require("SNPRelate")          }
if (!require("conStruct"))         { install.packages("conStruct")                      ; require("conStruct")          }
if (!require("constructhelpers"))  { remotes::install_github("kdm9/constructhelpers")   ; require("constructhelpers")   }

knitr::opts_chunk$set(
  warnings=F
)
if (file.exists("data/cache/01_hpa-geogenetics.Rda")) load(file="data/cache/01_hpa-geogenetics.Rda")

NCPUS = as.integer(Sys.getenv("NCPUS", parallel::detectCores(logical=F)))
registerDoParallel(cores=NCPUS)
cat(paste("Using", NCPUS, "cores\n"))
```

## Geographic clustering

First, we need to select samples and find geographic clusters.

```{r geo.meta}
geo.dist.indiv = eu.geo %>%
    column_to_rownames(var = "ind") %>%
    select(longitude, latitude) %>%
    fossil::earth.dist()
geo.clust.indiv = geo.dist.indiv %>%
    hclust() %>%
    cutree(h=5) # cut at 5km radius
geo.cluster.name = sprintf("GC%02d", geo.clust.indiv)
eu.geo$geo.clust = geo.cluster.name
```

So at a population radius of 5km, we have `r length(geo.cluster.name)`
clusters.

Here are the cluster sizes (y clusters of size x): 

```{r geo.clust.size}
table(table(geo.cluster.name))
```


## Basic genetics

Here we need to extract the SNP data, and reduce it to allele frequencies at
each geographic cluster, and remove snps with null variance.


First,  get the indivs by snps matrix (122x500k)

```{r gdsopen}
gds = snpgdsOpen("data/HaR.filtered_snps_final.PASS.bi.hardFiltered.indFiltered.noMit.reheader.gds", allow.duplicate=T)
gds.sum  = snpgdsSummary(gds)
gen = snpgdsGetGeno(gds, sample.id = samp.within.eur, with.id = T)
```

Now, we reduce the 122x500k matrix of SNPs to a 68x500k matrix of population
allele frequencies. We skip columns (SNPs) with null variance. 

```{r genpop}
gen.pop = xfun::cache_rds({
    N.SNP = ncol(gen$genotype)
    foreach(i=seq_len(N.SNP), .combine=cbind) %do% {
        v = var(gen$genotype[, i], na.rm=T)
        if (!is.finite(v) || v <=0) {
            return(NULL)
        }
        tapply(gen$genotype[, i], geo.cluster.name, function(x) {mean(x, na.rm=T)/2})
    }
}, file="02_01_genpop", dir="data/cache/",  compress="xz")
```



## Run construct

Here we do some data prep, then run all the construct runs needed to do cross
validation (NB: we don't use construct's own cross validation here as it runs
all K sequentially which makes it take K times as long as it needs to.

```{r geo.data}
geo.clust.dat = eu.geo %>%
    group_by(geo.clust, pop) %>%
    summarise(latitude = mean(latitude),
              longitude = mean(longitude)) %>%
    ungroup()
geo.clust.latlong = geo.clust.dat %>%
    select(longitude, latitude) %>% 
    as.matrix()
geo.clust.dist = geo.clust.latlong %>%
    fossil::earth.dist() %>%
    as.matrix()
```

So to run construct we shell out to the cluster, as it takes ages. So, we save
the inputs to an Rds and then load the results again here for plotting and
interpretation.


```{r run.xval}
cxv.big = xfun::cache_rds({
    kdm.x.validation <- function(train.prop = 0.9, n.reps, K, freqs = NULL, data.partitions = NULL, geoDist, coords, prefix, n.iter, make.figs = FALSE, save.files = FALSE, n.nodes=16, parallel=T, ...) {
        call.check <- conStruct:::check.xval.call(args <- as.list(environment()))
        data.partitions <- conStruct:::make.data.partitions(n.reps,freqs,train.prop)
        conStruct:::check.data.partitions.arg(args <- as.list(environment()))
        cat("Data partitions created successfully\n")
        n.mdl = 2 * n.reps * length(K)
        x.val = foreach::foreach(rep.no=1:n.reps, .combine=bind_rows) %:%
                foreach::foreach(k=K, .combine=bind_rows) %:%
                foreach::foreach(mdl=c("sp", "nsp"), .combine=bind_rows) %dopar% {
            spatial = mdl == "sp"
            cs = conStruct:::xval.conStruct(spatial = spatial, K = k, 
                            data = data.partitions[[rep.no]]$training, 
                            geoDist = geoDist, coords = coords, 
                            prefix = paste0(prefix, "_", mdl, "_", "rep", rep.no, "K", k), 
                            n.iter = n.iter, make.figs = make.figs, save.files = save.files)
            fit = conStruct:::fit.to.test(data.partitions[[rep.no]]$testing, cs[[1]]) %>%
                unlist()
            cat(paste0("mdl=", mdl, " K=",k, " rep=", rep.no, " Done\n"))
            tibble(mdl=mdl, K=k, rep=rep.no, construct.res=cs, mdl.fit=list("fit"=fit))
        }
        list(res=x.val, data.parts=data.partitions)
    }

    kdm.x.validation(
        prefix="out/Hpa_cs/HpA_run_tmp",
        freqs=gen.pop,
        coords=geo.clust.latlong,
        geoDist=geo.clust.dist,
        K=1:8,
        train.prop=0.9,
        n.reps=16,
        n.iter=20000,
        n.nodes=NCPUS,
        save.files=F,
        make.figs=T)
}, file="02_02_cs_xval", dir="data/cache/",  compress="xz")
```

# Summarise construct cross validation

First, collect all the bits of data together like they should have been in the original R code (not rewriting it yet as i'll make it a helper pkg soon).

```{r xval.ll, message=F}
cxv = cxv.big$res %>%
    mutate(ll.mean = purrr::map_dbl(mdl.fit, mean, na.rm=T),
           data.part = purrr::map(rep, function(r) cxv.big$data.parts[[r]]),
           data.block = purrr::pmap(list(K, mdl, rep, data.part), function(k, m, r, dp) {
                sd.dist.list = conStruct:::standardize.distances(geo.clust.dist)
                data.partition = dp$training
                db = list(
                    N = nrow(geo.clust.latlong),
                    K=k,
                    spatial=m == "sp",
                    L = data.partition$n.loci,
                    coords=geo.clust.latlong,
                    obsCov = data.partition$data,
			        geoDist = sd.dist.list$std.D,
			        sd.geoDist = sd.dist.list$stdev.D,
			        varMeanFreqs = data.partition$varMeanFreqs
                )
                conStruct:::validate.data.block(db)
            }))
cxv
```


Here we plot the log likelihoods for each run. NB that in theory, the 

```{r}
cxv.ll = cxv %>%
    select(-construct.res, -mdl.fit) %>%
    group_by(mdl) %>%
    mutate(std.ll.mean = ll.mean - max(ll.mean)) %>%
    ungroup()
ggplot(cxv.ll, aes(K, std.ll.mean)) +
    geom_point(position="jitter") +
    facet_wrap(~mdl)+
    theme_bw()
ggsave("out/Hpa_cs_xval_ll.pdf", width=8,height=5)
```


```{r layer.contrib}
layer = cxv %>%
    group_by(mdl, K) %>%
    mutate(layer.contrib =  purrr::map2(construct.res, data.block, function (x, y) {
            lc = conStruct:::calculate.layer.contribution(x,y)
            lr = 1:length(lc)
            tibble(layer = lr, layer.contrib=sort(unlist(lc), dec=T))
        })
    ) %>%
    select(mdl, K, rep, layer.contrib) %>%
    unnest(layer.contrib)
```

```{r plot.lc}
plot.dat =  layer %>%
    filter(K>1) %>%
    mutate(
        K=as.factor(sprintf("K=%d", K)),
        layer=as.factor(layer),
        rep=as.factor(sprintf("Rep%02d", rep)),
        mdl=fct_relevel(ifelse(mdl == "sp", "Spatial", "Non-Spatial"), "Spatial", "Non-Spatial")
    )
ggplot(plot.dat, aes(x=layer, y=layer.contrib)) +
    geom_violin() +
    #geom_point(aes(colour=rep)) + 
    #scale_colour_manual(values=rainbow(length(levels(plot.dat$rep))), name="Replicate") +
    labs(y="Layer Contribution", x="Layer (ancestral popn.)") +
    facet_grid(mdl ~ K, scales="free_x", space = "free_x") +
    theme_bw()
ggsave("out/Hpa_cs_xval_lc.pdf", width=8,height=5)
```

## K=2 and K=3 Piecharts

```{r eval=F, include=F}
basemap.terr = get_stamenmap(eu.bbox, zoom=5, maptype="terrain-background")
basemap.plt =  ggmap(basemap.terr, darken=c(0.4, "white"), legend="topleft", extent="device")

qmat = cxv.big$res %>%
    filter(K %in% 2:4) %>%
    mutate(qmat=purrr::map(construct.res, function(cs) {
            Q = cs$MAP$admix.proportions %>%
                as.data.frame()
            colnames(Q) = sprintf("L%d", 1:ncol(Q))
            G = as.data.frame(geo.clust.latlong)
            bind_cols(G, Q) %>%
                gather("layer", "value", -longitude, -latitude) %>%
                as_tibble()
        })) %>%
    mutate(plt =purrr::map(qmat, function(q) {
            basemap.plt + 
                geom_scatterpie(aes(longitude, latitude), data=q, cols="layer", long_format=TRUE, legend_name="Layer") +
                labs(x="Longitude", y="Latitude") +
                theme_bw()
        }))
```

Here we use conStruct's `make.all.the.plots` to generate plots for each run.

```{r matp}
if (!dir.exists("out/matp/Hpa_csbig")) dir.create("out/matp/Hpa_csbig", recursive = T)

cxv %>%
    filter(K %in% 1:4, rep %in% 1:4) %>%
    mutate(code=sprintf("K%d_%s_rep%d", K, mdl, rep)) %>%
    select(code, construct.res, data.block) %>%
    purrr::pmap(function(code, construct.res, data.block) {
            conStruct::make.all.the.plots(list(chain_1=construct.res), data.block, paste0("out/matp/Hpa_csbig/", code, ".pdf"))
        }) %>%
    invisible()
```


<!-- FINALISE & CLEAN UP -->
```{r cleanup, include=F, cache=F}
```
